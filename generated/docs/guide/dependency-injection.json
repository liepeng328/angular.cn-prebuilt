{
  "id": "guide/dependency-injection",
  "title": "Angular 依赖注入",
  "contents": "\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"angular-dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#angular-dependency-injection\"><i class=\"material-icons\">link</i></a>Angular Dependency Injection</h1>\n<h1 translation-result=\"\" id=\"angular-dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#angular-dependency-injection\"><i class=\"material-icons\">link</i></a>Angular 依赖注入</h1>\n<p translation-origin=\"off\"><strong>Dependency Injection (DI)</strong> is a way to create objects that depend upon other objects.\nA Dependency Injection system supplies the dependent objects (called the <em>dependencies</em>)\nwhen it creates an instance of an object.</p>\n<p translation-result=\"\"><strong>依赖注入（DI）</strong>是用来创建对象及其依赖的其它对象的一种方式。\n当依赖注入系统创建某个对象实例时，会负责提供该对象所依赖的对象（称为该对象的<em>依赖</em>）。</p>\n<p translation-origin=\"off\">The <a href=\"guide/dependency-injection-pattern\">Dependency Injection pattern</a> page describes this general approach.\n<em>The guide you're reading now</em> explains how Angular's own Dependency Injection system works.</p>\n<p translation-result=\"\"><a href=\"guide/dependency-injection-pattern\">依赖注入模式</a>中讲解了这种通用的方法。\n<em>在这里</em></p>\n<h2 translation-origin=\"off\" id=\"di-by-example\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#di-by-example\"><i class=\"material-icons\">link</i></a>DI by example</h2>\n<h2 translation-result=\"\" id=\"di-by-example\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#di-by-example\"><i class=\"material-icons\">link</i></a>DI 的例子</h2>\n<p translation-origin=\"off\">You'll learn Angular Dependency Injection through a discussion of the sample app that accompanies this guide.\nRun the <live-example></live-example> anytime.</p>\n<p translation-result=\"\">在这篇指南中，你将会通过对一个范例应用的讨论来学习 Angular 的依赖注入技术。</p>\n<p translation-origin=\"off\">Start by reviewing this simplified version of the <em>heroes</em> feature\nfrom the <a href=\"tutorial/\">The Tour of Heroes</a>.</p>\n<p translation-result=\"\">我们先从<a href=\"tutorial/\">《英雄指南》</a>中<em>英雄</em>特性区的一个简化版本开始。</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport class Hero {\n  id: number;\n  name: string;\n  isSecret = false;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from './hero';\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: 'Mr. Nice' },\n  { id: 12, isSecret: false, name: 'Narco' },\n  { id: 13, isSecret: false, name: 'Bombasto' },\n  { id: 14, isSecret: false, name: 'Celeritas' },\n  { id: 15, isSecret: false, name: 'Magneta' },\n  { id: 16, isSecret: false, name: 'RubberMan' },\n  { id: 17, isSecret: false, name: 'Dynama' },\n  { id: 18, isSecret: true,  name: 'Dr IQ' },\n  { id: 19, isSecret: true,  name: 'Magma' },\n  { id: 20, isSecret: true,  name: 'Tornado' }\n];\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-origin=\"off\">The <code>HeroesComponent</code> is the top-level heroes component.\nIt's only purpose is to display the <code>HeroListComponent</code>\nwhich displays a list of hero names.</p>\n<p translation-result=\"\"><code>HeroesComponent</code> 是位于顶级的组件。\n它唯一的用途是显示 <code>HeroListComponent</code>，它显示一个英雄名字的列表。</p>\n<p translation-origin=\"off\">This version of the <code>HeroListComponent</code> gets its <code>heroes</code> from the <code>HEROES</code> array, an in-memory collection\ndefined in a separate <code>mock-heroes</code> file.</p>\n<p translation-result=\"\">这个版本的 <code>HeroListComponent</code> 从 <code>HEROES</code> 数组（定义在 <code>mock-heroes</code> 文件中的内存数组）中获取 <code>heroes</code>。</p>\n<code-example title=\"src/app/heroes/hero-list.component.ts (class)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n</code-example>\n<p translation-origin=\"off\">That may suffice in the early stages of development, but it's far from ideal.\nAs soon as you try to test this component or get heroes from a remote server,\nyou'll have to change the implementation of <code>HerosListComponent</code> and\nreplace every other use of the <code>HEROES</code> mock data.</p>\n<p translation-result=\"\">在开发的早期阶段，这就够用了，不过还很不理想。\n当要测试这个组件或者要从远端服务器获取英雄数据时，你就不得不去修改 <code>HeroesListComponent</code> 的实现，并要替换所有使用了 <code>HEROES</code> 模拟数据的地方。</p>\n<p translation-origin=\"off\">It's better to hide these details inside a <em>service</em> class,\n<a href=\"guide/dependency-injection#one-class-per-file\">defined in its own file</a>.</p>\n<p translation-result=\"\">最好隐藏服务类的这些内部实现细节，那就先<a href=\"guide/dependency-injection#one-class-per-file\">把它定义在自己的文件中</a>。</p>\n<h2 translation-origin=\"off\" id=\"create-an-injectable-heroservice\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-an-injectable-heroservice\"><i class=\"material-icons\">link</i></a>Create an injectable <em>HeroService</em></h2>\n<h2 translation-result=\"\" id=\"create-an-injectable-emheroserviceem\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-an-injectable-emheroserviceem\"><i class=\"material-icons\">link</i></a>创建一个可注入的 <code>HeroService</code></h2>\n<p translation-origin=\"off\">The <a href=\"https://cli.angular.io/\"><strong>Angular CLI</strong></a> can generate a new <code>HeroService</code> class in the <code>src/app/heroes</code> folder with this command.</p>\n<p translation-result=\"\"><a href=\"https://cli.angular.io/\"><strong>Angular CLI</strong></a> 可以使用下列命令在 <code>src/app/heroes</code> 目录下新建一个 <code>HeroService</code> 类。</p>\n<code-example language=\"sh\" class=\"code-shell\">\n\nng generate service heroes/hero\n\n</code-example>\n<p translation-origin=\"off\">That command creates the following <code>HeroService</code> skeleton.</p>\n<p translation-result=\"\">这条命令会创建如下的 <code>HeroService</code> 骨架代码：</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" title=\"src/app/heroes/hero.service.ts (CLI-generated)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">Assume for now that the <a href=\"guide/dependency-injection#injectable\"><code>@Injectable</code> decorator</a> is an essential ingredient in every Angular service definition.\nThe rest of the class has been rewritten to expose a <code>getHeroes</code> method\nthat returns the same mock data as before.</p>\n<p translation-result=\"\">目前先把 <a href=\"guide/dependency-injection#injectable\"><code>@Injectable</code> 装饰器</a>当做定义每个 Angular 服务时的必备部分。\n把该类的其它部分改写为暴露一个返回和以前一样的 mock 数据的 <code>getHeroes</code> 方法。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.1.ts\" title=\"src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">Of course, this isn't a real data service.\nIf the app were actually getting data from a remote server,\nthe <code>getHeroes</code> method signature would have to be asynchronous.</p>\n<p translation-result=\"\">当然，这还不是真正的数据服务。\n如果该应用真的从远端服务器获取数据，那么 <code>getHeroes</code> 的方法签名就应该是异步形式的。</p>\n<p translation-origin=\"off\">That's a defect we can safely ignore in this guide where our focus is on\n<em>injecting the service</em> into the <code>HeroList</code> component.</p>\n<p translation-result=\"\">在这一章我们可以忽略这个问题，因为这里的焦点在于<em>把服务注入</em>到 <code>HeroListComponent</code> 组件中。</p>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<h2 translation-origin=\"off\" id=\"register-a-service-provider\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#register-a-service-provider\"><i class=\"material-icons\">link</i></a>Register a service provider</h2>\n<h2 translation-result=\"\" id=\"register-a-service-provider\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#register-a-service-provider\"><i class=\"material-icons\">link</i></a>注册服务提供商</h2>\n<p translation-origin=\"off\">A <em>service</em> is just a class in Angular until you register it with an Angular dependency injector.</p>\n<p translation-result=\"\">在你把 Angular 中的<em>服务</em>注册进依赖注入器（injector）之前，它只是一个普通的类。</p>\n<p translation-origin=\"off\">An Angular injector is responsible for creating service instances and injecting them into classes like the <code>HeroListComponent</code>.</p>\n<p translation-result=\"\">Angular 的依赖注入器负责创建服务的实例，并把它们注入到像 <code>HeroListComponent</code> 这样的类中。</p>\n<p translation-origin=\"off\">You rarely create an Angular injector yourself.\nAngular creates injectors for you as it executes the app,\nstarting with the <em>root injector</em> that it creates during the <a href=\"guide/bootstrapping\">bootstrap process</a>.</p>\n<p translation-result=\"\">你很少需要自己创建 Angular 的依赖注入器。\n当 Angular 运行本应用时，它会为你创建这些注入器，首先会在<a href=\"guide/bootstrapping\">引导过程</a>中创建一个<em>根注入器</em>。</p>\n<p translation-origin=\"off\">You do have to register <em>providers</em> with an injector\nbefore the injector can create that service.</p>\n<p translation-result=\"\">但在注入器能创建服务之前，你得先往注入器中注入这个服务的<em>提供商</em>。</p>\n<p translation-origin=\"off\"><strong>Providers</strong> tell the injector <em>how to create the service</em>.\nWithout a provider, the injector would not know\nthat it is responsible for injecting the service\nnor be able to create the service.</p>\n<p translation-result=\"\"><strong>提供商</strong>会告诉注入器<em>如何创建该服务</em>。\n如果没有提供商，注入器既不知道它该负责创建该服务，也不知道如何创建该服务。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">You'll learn much more about <em>providers</em> <a href=\"guide/dependency-injection#providers\">below</a>.\nFor now it is sufficient to know that they create services\nand must be registered with an injector.</p>\n<p translation-result=\"\">你可以在<a href=\"guide/dependency-injection#providers\">稍后的部分</a>学到更多关于<em>提供商</em>的知识。\n不过目前，只要知道它们用于创建服务，以及它们必须用注入器进行注册就行了。</p>\n</div>\n<p translation-origin=\"off\">You can register a provider with any Angular decorator that supports the  <strong><code>providers</code> array property</strong>.</p>\n<p translation-result=\"\">你可以使用 Angular 中那些支持 <code>providers</code> 数组属性的装饰器来注册提供商。</p>\n<p translation-origin=\"off\">Many Angular decorators accept metadata with a <code>providers</code> property.\nThe two most important examples are <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> and <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>.</p>\n<p translation-result=\"\">很多 Angular 的装饰器都支持带有 <code>providers</code> 属性的元数据。\n最重要的两个例子是 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 和 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p>\n<a id=\"register-providers-component\"></a>\n<h3 translation-origin=\"off\" id=\"component-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#component-providers\"><i class=\"material-icons\">link</i></a><em>@Component</em> providers</h3>\n<h3 translation-result=\"\" id=\"emcomponentem-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#emcomponentem-providers\"><i class=\"material-icons\">link</i></a>在组件中注册提供商</h3>\n<p translation-origin=\"off\">Here's a revised <code>HeroesComponent</code> that registers the <code>HeroService</code> in its <code>providers</code> array.</p>\n<p translation-result=\"\">下面是修改过的<code>HerosComponent</code>，把<code>HeroService</code>注册到了它的<code>providers</code>数组中。</p>\n<code-example path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" title=\"src/app/heroes/heroes.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-example>\n<a id=\"register-providers-ngmodule\"></a>\n<h3 translation-origin=\"off\" id=\"ngmodule-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#ngmodule-providers\"><i class=\"material-icons\">link</i></a><em>@NgModule</em> providers</h3>\n<h3 translation-result=\"\" id=\"emngmoduleem-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#emngmoduleem-providers\"><i class=\"material-icons\">link</i></a><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中的 <code>providers</code></h3>\n<p translation-origin=\"off\">In the following excerpt, the root <code>AppModule</code> registers two providers in its <code>providers</code> array.</p>\n<p translation-result=\"\">在下面的代码片段中，根模块 <code>AppModule</code> 在自己的 <code>providers</code> 数组中注册了两个提供商。</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (providers)\" region=\"providers\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<p translation-origin=\"off\">The first entry registers the <code>UserService</code> class (<em>not shown</em>) under the <code>UserService</code> <em>injection token</em>.\nThe second registers a value (<code>HERO_DI_CONFIG</code>) under the <code>APP_CONFIG</code> <em>injection token</em>.</p>\n<p translation-result=\"\">第一条使用 <code>UserService</code> 这个<em>注入令牌（injection token）</em>注册了 <code>UserService</code> 类（代码中未显示）。\n第二条使用 <code>APP_CONFIG</code> 这个注入令牌注册了一个值（<code>HERO_DI_CONFIG</code>）。</p>\n<p translation-origin=\"off\">Thanks to these registrations, Angular can inject the <code>UserService</code> or the <code>HERO_DI_CONFIG</code> value\ninto any class that it creates.</p>\n<p translation-result=\"\">得益于这些注册语句，Angular 现在可以向它创建的任何类中注册 <code>UserService</code> 或 <code>HERO_DI_CONFIG</code> 值了。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">You'll learn about <em>injection tokens</em> and <em>provider</em> syntax <a href=\"guide/dependency-injection#providers\">below</a>.</p>\n<p translation-result=\"\"><a href=\"guide/dependency-injection#providers\">稍后</a>你就会学到关于<em>注入令牌</em>和服务提供商语法的知识。</p>\n</div>\n<a id=\"ngmodule-vs-comp\"></a>\n<h3 translation-origin=\"off\" id=\"ngmodule-or-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#ngmodule-or-component\"><i class=\"material-icons\">link</i></a><em>@NgModule</em> or <em>@Component</em>?</h3>\n<h3 translation-result=\"\" id=\"emngmoduleem-or-emcomponentem\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#emngmoduleem-or-emcomponentem\"><i class=\"material-icons\">link</i></a><em>@NgModule</em> 还是 <em>@Component</em>?</h3>\n<p translation-origin=\"off\">Should you register a service with an Angular module or with a component?\nThe two choices lead to differences in service <em>scope</em> and service <em>lifetime</em>.</p>\n<p translation-result=\"\">你该使用 Angular 的模块还是组件来注册服务呢？\n这两个选择的差别在于服务的<em>范围</em>和<em>生命周期</em>。</p>\n<p translation-origin=\"off\"><strong>Angular module providers</strong> (<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>.providers</code>) are registered with the application's root injector.\nAngular can inject the corresponding services in any class it creates.\nOnce created, a service instance lives for the life of the app and Angular injects this one service instance in every class that needs it.</p>\n<p translation-result=\"\"><strong>Angular 模块中的 <code>providers</code></strong>（<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>.providers</code>）是注册在应用的根注入器下的。\n因此，Angular 可以往它所创建的任何类中注入相应的服务。\n一旦创建，服务的实例就会存在于该应用的全部生存期中，Angular 会把这一个服务实例注入到需求它的每个类中。</p>\n<p translation-origin=\"off\">You're likely to inject the <code>UserService</code> in many places throughout the app\nand will want to inject the same service instance every time.\nProviding the <code>UserService</code> with an Angular module is a good choice.</p>\n<p translation-result=\"\">如果你想要把这个 <code>UserService</code> 注入到应用中的很多地方，并且期望每次注入的都是同一个服务实例，那么在 Angular 的模块中提供 <code>UserService</code> 就是不错的选择。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">To be precise, Angular module providers are registered with the root injector\n<em>unless the module is</em> <a href=\"guide/lazy-loading-ngmodules\">lazy loaded</a>.\nIn this sample, all modules are <em>eagerly loaded</em> when the application starts,\nso all module providers are registered with the app's root injector.</p>\n<p translation-result=\"\">严格来说，Angular 模块中的服务提供商会注册到根注入器上，但是，<a href=\"guide/lazy-loading-ngmodules\">惰性加载</a>的模块是例外。\n在这个例子中，所有模块都是在应用启动时<em>立即加载</em>的，因此模块上的所有服务提供商都注册到了应用的根注入器上。</p>\n</div><br>\n<hr>\n<p translation-origin=\"off\"><strong>A component's providers</strong> (<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>.providers</code>) are registered with each component instance's own injector.</p>\n<p translation-result=\"\"><strong>组件的提供商</strong>（<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>.providers</code>）会注册到每个组件实例自己的注入器上。</p>\n<p translation-origin=\"off\">Angular can only inject the corresponding services in that component instance or one of its descendant component instances.\nAngular cannot inject the same service instance anywhere else.</p>\n<p translation-result=\"\">因此 Angular 只能在该组件及其各级子组件的实例上注入这个服务实例，而不能在其它地方注入这个服务实例。</p>\n<p translation-origin=\"off\">Note that a component-provided service may have a limited lifetime. Each new instance of the component gets its own instance of the service\nand, when the component instance is destroyed, so is that service instance.</p>\n<p translation-result=\"\">注意，由组件提供的服务，也同样具有有限的生命周期。组件的每个实例都会有它自己的服务实例，并且，当组件实例被销毁的时候，服务的实例也同样会被销毁。</p>\n<p translation-origin=\"off\">In this sample app, the <code>HeroComponent</code> is created when the application starts\nand is never destroyed so the <code>HeroService</code> created for the <code>HeroComponent</code> also live for the life of the app.</p>\n<p translation-result=\"\">在这个范例应用中，<code>HeroComponent</code> 会在应用启动时创建，并且它从未销毁，因此，由 <code>HeroComponent</code> 创建的 <code>HeroService</code> 也同样会活在应用的整个生命周期中。</p>\n<p translation-origin=\"off\">If you want to restrict <code>HeroService</code> access to the <code>HeroesComponent</code> and its nested <code>HeroListComponent</code>,\nproviding the <code>HeroService</code> in the <code>HeroComponent</code> may be a good choice.</p>\n<p translation-result=\"\">如果你要把 <code>HeroService</code> 的访问权限定在 <code>HeroesComponent</code> 及其嵌套的 <code>HeroListComponent</code> 中，那么在 <code>HeroesComponent</code> 中提供这个 <code>HeroService</code> 就是一个好选择。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">The scope and lifetime of component-provided services is a consequence of <a href=\"guide/dependency-injection#component-child-injectors\">the way Angular creates component instances</a>. </p>\n<p translation-result=\"\">由组件提供的服务，其范围和生命周期是 <a href=\"guide/dependency-injection#component-child-injectors\">Angular 如何创建组件实例</a> 的必然结果。</p>\n</div>\n<h2 translation-origin=\"off\" id=\"inject-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#inject-a-service\"><i class=\"material-icons\">link</i></a>Inject a service</h2>\n<h2 translation-result=\"\" id=\"inject-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#inject-a-service\"><i class=\"material-icons\">link</i></a>注入某个服务</h2>\n<p translation-origin=\"off\">The <code>HeroListComponent</code> should get heroes from the <code>HeroService</code>.</p>\n<p translation-result=\"\"><code>HeroListComponent</code> 应该从 <code>HeroService</code> 中获取这些英雄数据。</p>\n<p translation-origin=\"off\">The component shouldn't create the <code>HeroService</code> with <code>new</code>.\nIt should ask for the <code>HeroService</code> to be injected.</p>\n<p translation-result=\"\">该组件不应该使用 <code>new</code> 来创建 <code>HeroService</code>。\n它应该要求注入 <code>HeroService</code>。</p>\n<p translation-origin=\"off\">You can tell Angular to inject a dependency in the component's constructor by specifying a <strong>constructor parameter with the dependency type</strong>.\nHere's the <code>HeroListComponent</code> constructor, asking for the <code>HeroService</code> to be injected.</p>\n<p translation-result=\"\">你可以通过<strong>在构造函数中添加一个带有该依赖类型的参数</strong>来要求 Angular 把这个依赖注入到组件的构造函数中。\n下面是 <code>HeroListComponent</code> 的构造函数，它要求注入 <code>HeroService</code>。</p>\n<code-example title=\"src/app/heroes/hero-list.component (constructor signature)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p translation-origin=\"off\">Of course, the <code>HeroListComponent</code> should do something with the injected <code>HeroService</code>.\nHere's the revised component, making use of the injected service, side-by-side with the previous version for comparison.</p>\n<p translation-result=\"\">当然，<code>HeroListComponent</code> 还应该使用注入的这个 <code>HeroService</code> 做点什么。\n下面输出修改过的组件，改用注入的服务，与前一个版本对比一下。</p>\n<code-tabs>\n\n  <code-pane title=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { Hero }        from './hero';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-origin=\"off\">Notice that the <code>HeroListComponent</code> doesn't know where the <code>HeroService</code> comes from.\n<em>You</em> know that it comes from the parent <code>HeroesComponent</code>.\nBut if you decided instead to provide the <code>HeroService</code> in the <code>AppModule</code>,\nthe <code>HeroListComponent</code> wouldn't change at all.\nThe <em>only thing that matters</em> is that the <code>HeroService</code> is provided in some parent injector.</p>\n<p translation-result=\"\">注意，<code>HeroListComponent</code> 并不知道 <code>HeroService</code> 来自哪里。\n当然<em>你自己</em>知道它来自父组件 <code>HeroesComponent</code>。\n但是如果你决定改在 <code>AppModule</code> 中提供 <code>HeroService</code>，<code>HeroListComponent</code> 不用做任何修改。\n它<em>唯一需要关心的事情</em>是 <code>HeroService</code> 是由某个父注入器提供的。</p>\n<a id=\"singleton-services\"></a>\n<h2 translation-origin=\"off\" id=\"singleton-services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#singleton-services\"><i class=\"material-icons\">link</i></a>Singleton services</h2>\n<h2 translation-result=\"\" id=\"singleton-services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#singleton-services\"><i class=\"material-icons\">link</i></a>单例服务</h2>\n<p translation-origin=\"off\">Services are singletons <em>within the scope of an injector</em>.\nThere is at most one instance of a service in a given injector.</p>\n<p translation-result=\"\">服务<em>在每个注入器的范围内</em>是单例的。\n在任何一个注入器中，最多只会有同一个服务的一个实例。</p>\n<p translation-origin=\"off\">There is only one root injector and the <code>UserService</code> is registered with that injector.\nTherefore, there can be just one <code>UserService</code> instance in the entire app\nand every class that injects <code>UserService</code> get this service instance.</p>\n<p translation-result=\"\">这里只有一个根注入器，而 <code>UserService</code> 就是在该注入器中注册的。\n所以，在整个应用中只能有一个 <code>UserService</code> 实例，每个要求注入 <code>UserService</code> 的类都会得到这个服务实例。</p>\n<p translation-origin=\"off\">However, Angular DI is a\n<a href=\"guide/hierarchical-dependency-injection\">hierarchical injection system</a>,\nwhich means that nested injectors can create their own service instances.\nAngular creates nested injectors all the time.</p>\n<p translation-result=\"\">不过，Angular DI 是一个 <a href=\"guide/hierarchical-dependency-injection\">多级注入系统</a>，这意味着各级注入器都可以创建它们自己的服务实例。\nAngular 总会创建多级注入器。</p>\n<a id=\"component-child-injectors\"></a>\n<h2 translation-origin=\"off\" id=\"component-child-injectors\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#component-child-injectors\"><i class=\"material-icons\">link</i></a>Component child injectors</h2>\n<h2 translation-result=\"\" id=\"component-child-injectors\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#component-child-injectors\"><i class=\"material-icons\">link</i></a>组件的子注入器</h2>\n<p translation-origin=\"off\">For example, when Angular creates a new instance of a component that has <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>.providers</code>,\nit also creates a new <em>child injector</em> for that instance.</p>\n<p translation-result=\"\">例如，当 Angular 创建一个带有 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>.providers</code> 的组件实例时，也会同时为这个实例创建一个新的<em>子注入器</em>。</p>\n<p translation-origin=\"off\">Component injectors are independent of each other and\neach of them creates its own instances of the component-provided services.</p>\n<p translation-result=\"\">组件注入器是彼此独立的，每一个都会为这些组件提供的服务创建单独的实例。</p>\n<p translation-origin=\"off\">When Angular destroys one of these component instance, it also destroys the\ncomponent's injector and that injector's service instances. </p>\n<p translation-result=\"\">当 Angular 销毁任何一个组件实例时，也会同时销毁组件的注入器以及该注入器中的那些服务实例。</p>\n<p translation-origin=\"off\">Thanks to <a href=\"guide/hierarchical-dependency-injection\">injector inheritance</a>,\nyou can still inject application-wide services into these components.\nA component's injector is a child of its parent component's injector,\nand a descendent of its parent's parent's injector, and so on all the way back to the application's <em>root</em> injector.\nAngular can inject a service provided by any injector in that lineage.</p>\n<p translation-result=\"\">在<a href=\"guide/hierarchical-dependency-injection\">注入器继承机制</a>的帮助下，你仍然可以把全应用级的服务注入到这些组件中。\n组件的注入器也是其父组件的注入器的子注入器，这同样适用于其父组件的父组件的注入器，以此类推，最终会回到应用的<em>根</em>注入器。\nAngular 可以注入由这个注入器谱系提供的任何一个注入器。</p>\n<p translation-origin=\"off\">For example, Angular could inject a <code>HeroListComponent</code>\nwith both the <code>HeroService</code> provided in <code>HeroComponent</code>\nand the <code>UserService</code> provided in <code>AppModule</code>.</p>\n<p translation-result=\"\">比如，Angular 可以把由 <code>HeroComponent</code> 提供的 <code>HeroService</code> 和由 <code>AppModule</code> 提供的 <code>UserService</code> 注入到 <code>HeroService</code> 中。</p>\n<a id=\"testing-the-component\"></a>\n<h2 translation-origin=\"off\" id=\"testing-the-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#testing-the-component\"><i class=\"material-icons\">link</i></a>Testing the component</h2>\n<h2 translation-result=\"\" id=\"testing-the-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#testing-the-component\"><i class=\"material-icons\">link</i></a>测试组件</h2>\n<p translation-origin=\"off\">Earlier you saw that designing a class for dependency injection makes the class easier to test.\nListing dependencies as constructor parameters may be all you need to test application parts effectively.</p>\n<p translation-result=\"\">前面强调过，设计一个适合依赖注入的类，可以让这个类更容易测试。\n要有效的测试应用中的一部分，只需要在构造函数的参数中列出依赖。</p>\n<p translation-origin=\"off\">For example, you can create a new <code>HeroListComponent</code> with a mock service that you can manipulate\nunder test:</p>\n<p translation-result=\"\">例如，新建的<code>HeroListComponent</code>实例使用一个模拟 (mock) 服务，以便可以在测试中操纵它：</p>\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" title=\"src/app/test.component.ts\" linenums=\"false\">\nconst expectedHeroes = [{name: 'A'}, {name: 'B'}]\nconst mockService = &#x3C;HeroService> {getHeroes: () => expectedHeroes }\n\nit('should have heroes when HeroListComponent created', () => {\n  // Pass the mock to the constructor as the Angular injector would\n  const component = new HeroListComponent(mockService);\n  expect(component.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">Learn more in the <a href=\"guide/testing\">Testing</a> guide.</p>\n<p translation-result=\"\">要学习更多知识，参见<a href=\"guide/testing\">测试</a>一章。</p>\n</div>\n<a id=\"service-needs-service\"></a>\n<h2 translation-origin=\"off\" id=\"when-the-service-needs-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#when-the-service-needs-a-service\"><i class=\"material-icons\">link</i></a>When the service needs a service</h2>\n<h2 translation-result=\"\" id=\"when-the-service-needs-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#when-the-service-needs-a-service\"><i class=\"material-icons\">link</i></a>当服务需要别的服务时</h2>\n<p translation-origin=\"off\">The <code>HeroService</code> is very simple. It doesn't have any dependencies of its own.</p>\n<p translation-result=\"\">这个<code>HeroService</code>非常简单。它本身不需要任何依赖。</p>\n<p translation-origin=\"off\">What if it had a dependency? What if it reported its activities through a logging service?\nYou'd apply the same <em>constructor injection</em> pattern,\nadding a constructor that takes a <code>Logger</code> parameter.</p>\n<p translation-result=\"\">如果它也有依赖，该怎么办呢？例如，它需要通过日志服务来汇报自己的活动。\n我们同样用<em>构造函数注入</em>模式，来添加一个带有<code>Logger</code>参数的构造函数。</p>\n<p translation-origin=\"off\">Here is the revised <code>HeroService</code> that injects the <code>Logger</code>, side-by-side with the previous service for comparison.</p>\n<p translation-result=\"\">下面是修改后的 <code>HeroService</code>，它注入了 <code>Logger</code>，对比前后这两个版本：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\nimport { Logger }     from '../logger.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-origin=\"off\">The constructor asks for an injected instance of a <code>Logger</code> and stores it in a private field called <code>logger</code>.\nThe <code>getHeroes()</code> method logs a message when asked to fetch heroes.</p>\n<p translation-result=\"\">这个构造函数要求注入一个<code>Logger</code>类的实例，并把它存到名为<code>logger</code>的私有字段中。\n当请求英雄数据时，<code>getHeroes()</code>中就会记录一个消息。</p>\n<a id=\"logger-service\"></a>\n<h4 translation-origin=\"off\" id=\"the-dependent-logger-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-dependent-logger-service\"><i class=\"material-icons\">link</i></a>The dependent <em>Logger</em> service</h4>\n<h4 translation-result=\"\" id=\"the-dependent-emloggerem-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-dependent-emloggerem-service\"><i class=\"material-icons\">link</i></a>被依赖的 <code>Logger</code> 服务</h4>\n<p translation-origin=\"off\">The sample app's <code>Logger</code> service is quite simple:</p>\n<p translation-result=\"\">这个范例应用的 <code>Logger</code> 服务非常简单：</p>\n<code-example path=\"dependency-injection/src/app/logger.service.ts\" title=\"src/app/logger.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Logger {\n  logs: string[] = []; // capture logs for testing\n\n  log(message: string) {\n    this.logs.push(message);\n    console.log(message);\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">If the app didn't provide this <code>Logger</code>,\nAngular would throw an exception when it looked for a <code>Logger</code> to inject\ninto the <code>HeroService</code>.</p>\n<p translation-result=\"\">如果该应用没有提供这个 <code>Logger</code> 服务，当 Angular 试图把 <code>Logger</code> 注入到 <code>HeroService</code> 中时，就会抛出一个异常。</p>\n<code-example language=\"sh\" class=\"code-shell\">\n\n  ERROR Error: No provider for Logger!\n\n</code-example>\n<p translation-origin=\"off\">Because a singleton logger service is useful everywhere,\nit's provided in the root <code>AppModule</code>.</p>\n<p translation-result=\"\">因为 <code>Logger</code> 服务的单例应该随处可用，所以要在根模块 <code>AppModule</code> 中提供它。</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (providers)\" region=\"providers-2\">\nproviders: [\n  Logger,\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<a id=\"injectable\"></a>\n<h2 translation-origin=\"off\" id=\"injectable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injectable\"><i class=\"material-icons\">link</i></a><em>@Injectable()</em></h2>\n<p translation-origin=\"off\">The <strong><a href=\"api/core/Injectable\">@Injectable()</a></strong> decorator identifies a service class\nthat <em>might</em> require injected dependencies.</p>\n<p translation-result=\"\"><strong><a href=\"api/core/Injectable\">@Injectable()</a></strong> 装饰器表示<em>可能</em>需要往这个服务类中注入其它依赖。</p>\n<p translation-origin=\"off\">The <code>HeroService</code> must be annotated with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> because it requires an injected <code>Logger</code>.</p>\n<p translation-result=\"\"><code>HeroService</code> 必须带有 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器，因为它需要把 <code>Logger</code> 注入进来。</p>\n<div class=\"alert is-important\">\n<p translation-origin=\"off\">Always write <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> with parentheses, not just <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>.</p>\n<p translation-result=\"\">写 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 时必须带括号，不能只写 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>。</p>\n</div>\n<p translation-origin=\"off\">When Angular creates a class whose constructor has parameters,\nit looks for type and injection metadata about those parameters\nso that it can inject the right service.</p>\n<p translation-result=\"\">当 Angular 要创建一个构造函数中带参数的类时，会先查找这些参数的类型，以便根据这些参数的元数据注入正确的服务。</p>\n<p translation-origin=\"off\">If Angular can't find that parameter information, it throws an error.</p>\n<p translation-result=\"\">如果不能找到该参数的信息，Angular 就会报错。</p>\n<p translation-origin=\"off\">Angular can only find the parameter information <em>if the class has a decorator of some kind</em>.\nWhile <em>any</em> decorator will do,\nthe <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator is the standard decorator for service classes.</p>\n<p translation-result=\"\">Angular 只能在<em>带有某种装饰器的类</em>上查找参数信息。<em>任何</em>装饰器都可以，而 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器是各种服务类的标准装饰器。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">The decorator requirement is imposed by TypeScript.</p>\n<p translation-result=\"\">之所以必须有装饰器，是因为 TypeScript 强制要求的。</p>\n<p translation-origin=\"off\">TypeScript normally discards parameter type information when it <em>transpiles</em> the code to JavaScript.\nIt preserves this information if the class has a decorator\nand the <code>emitDecoratorMetadata</code> compiler option is set <code>true</code>\nin TypeScript's <code>tsconfig.json</code> configuration file, .</p>\n<p translation-result=\"\">当把 TypeScript 转译成 JavaScript 时，通常会丢弃参数的类型信息。\n但当该类带有装饰器并且当 <code>tsconfig.json</code> 配置文件中的 <code>emitDecoratorMetadata</code> 编译选项为 <code>true</code> 时，它就会保留这些信息。</p>\n<p translation-origin=\"off\">The CLI configures <code>tsconfig.json</code> with <code>emitDecoratorMetadata: true</code>\nIt's your job to put <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> on your service classes.</p>\n<p translation-result=\"\">CLI 生成的 <code>tsconfig.json</code> 中已经有 <code>emitDecoratorMetadata: true</code> 选项了，你只要把 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 加到你的服务类上就可以了。</p>\n</div>\n<p translation-origin=\"off\">The <code>Logger</code> service is annotated with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator too,\nalthough it has no constructor and no dependencies.</p>\n<p translation-result=\"\"><code>Logger</code> 服务也带有 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器，不过它没有构造器，也没有依赖。</p>\n<p translation-origin=\"off\">In fact, <em>every</em> Angular service class in this app is annotated with the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator, whether or not it has a constructor and dependencies.\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> is a required coding style for services.</p>\n<p translation-result=\"\">该应用中的<em>每个</em> Angular 服务类不管有没有构造器和依赖，都带有 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器。\n事实上，<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 是风格指南中对服务类的要求。</p>\n<a id=\"providers\"></a>\n<h2 translation-origin=\"off\" id=\"providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#providers\"><i class=\"material-icons\">link</i></a>Providers</h2>\n<h2 translation-result=\"\" id=\"providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#providers\"><i class=\"material-icons\">link</i></a>服务提供商们</h2>\n<p translation-origin=\"off\">A service provider <em>provides</em> the concrete, runtime version of a dependency value.\nThe injector relies on <strong>providers</strong> to create instances of the services\nthat the injector injects into components, directives, pipes, and other services.</p>\n<p translation-result=\"\">服务提供商<em>提供</em>依赖值的一个具体的、运行时的版本。\n注入器依靠<strong>提供商</strong>来创建服务的实例，注入器再将服务的实例注入组件、管道或其它服务。</p>\n<p translation-origin=\"off\">You must register a service <em>provider</em> with an injector, or it won't know how to create the service.</p>\n<p translation-result=\"\">必须为注入器注册一个服务的<em>提供商</em>，否则它就不知道该如何创建该服务。</p>\n<p translation-origin=\"off\">The next few sections explain the many ways you can specify a provider.</p>\n<p translation-result=\"\">在下面的几节中会解释指定提供商的多种方式。</p>\n<p translation-origin=\"off\">Almost all of the accompanying code snippets are extracts from the sample app's <code>providers.component.ts</code> file.</p>\n<p translation-result=\"\">几乎所有的代码片段都是从范例应用的 <code>providers.component.ts</code> 文件中提取出来的。</p>\n<h3 translation-origin=\"off\" id=\"the-class-as-its-own-provider\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-class-as-its-own-provider\"><i class=\"material-icons\">link</i></a>The class as its own provider</h3>\n<h3 translation-result=\"\" id=\"the-class-as-its-own-provider\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-class-as-its-own-provider\"><i class=\"material-icons\">link</i></a>把类作为它自己的提供商</h3>\n<p translation-origin=\"off\">There are many ways to <em>provide</em> something that looks and behaves like a <code>Logger</code>.\nThe <code>Logger</code> class itself is an obvious and natural provider.</p>\n<p translation-result=\"\">有很多方式可以<em>提供</em>一些实现 <code>Logger</code>类的东西。\n<code>Logger</code>类本身是一个显而易见而且自然而然的提供商。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p translation-origin=\"off\">But it's not the only way.</p>\n<p translation-result=\"\">但它不是唯一的途径。</p>\n<p translation-origin=\"off\">You can configure the injector with alternative providers that can deliver an object that behaves like a <code>Logger</code>.\nYou could provide a substitute class. You could provide a logger-like object.\nYou could give it a provider that calls a logger factory function.\nAny of these approaches might be a good choice under the right circumstances.</p>\n<p translation-result=\"\">可以用其它备选提供商来配置注入器，只要它们能交付一个行为类似于<code>Logger</code>的对象就可以了。\n可以提供一个替代类。你可以提供一个类似日志的对象。\n可以给它一个提供商，让它调用可以创建日志服务的工厂函数。\n所有这些方法，只要用在正确的场合，都可能是一个好的选择。</p>\n<p translation-origin=\"off\">What matters is that the injector has a provider to go to when it needs a <code>Logger</code>.</p>\n<p translation-result=\"\">重点是，当注入器需要一个<code>Logger</code>时，它得先有一个提供商。</p>\n<a id=\"provide\"></a>\n<h3 translation-origin=\"off\" id=\"the-provide-object-literal\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-provide-object-literal\"><i class=\"material-icons\">link</i></a>The <em>provide</em> object literal</h3>\n<h3 translation-result=\"\" id=\"the-emprovideem-object-literal-1\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-emprovideem-object-literal-1\"><i class=\"material-icons\">link</i></a><em>provide</em> 对象字面量</h3>\n<p translation-origin=\"off\">Here's the class-provider syntax again.</p>\n<p translation-result=\"\">下面是类提供商的另一种语法。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p translation-origin=\"off\">This is actually a shorthand expression for a provider registration\nusing a <em>provider</em> object literal with two properties:</p>\n<p translation-result=\"\">这其实是用于注册提供商的简写表达式。\n使用的是一个带有两个属性的<em>提供商</em>对象字面量：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p translation-origin=\"off\">The <code>provide</code> property holds the <a href=\"guide/dependency-injection#token\">token</a> that serves as the key for both locating a dependency value\nand registering the provider.</p>\n<p translation-result=\"\"><code>provide</code>属性保存的是<a href=\"guide/dependency-injection#token\">令牌 (token)</a>，它作为键值 (key) 使用，用于定位依赖值和注册提供商。</p>\n<p translation-origin=\"off\">The second property is always a provider definition object,\nwhich you can think of as a <em>recipe</em> for creating the dependency value.\nThere are many ways to create dependency values just as there are many ways to write a recipe.</p>\n<p translation-result=\"\">第二个是一个提供商定义对象。\n可以把它看做是指导如何创建依赖值的<em>配方</em>。\n有很多方式创建依赖值…… 也有很多方式可以写配方。</p>\n<a id=\"class-provider\"></a>\n<h3 translation-origin=\"off\" id=\"alternative-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#alternative-class-providers\"><i class=\"material-icons\">link</i></a>Alternative class providers</h3>\n<h3 translation-result=\"\" id=\"alternative-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#alternative-class-providers\"><i class=\"material-icons\">link</i></a>备选的类提供商</h3>\n<p translation-origin=\"off\">Occasionally you'll ask a different class to provide the service.\nThe following code tells the injector\nto return a <code>BetterLogger</code> when something asks for the <code>Logger</code>.</p>\n<p translation-result=\"\">某些时候，我们会请求一个不同的类来提供服务。\n下列代码告诉注入器，当有人请求<code>Logger</code>时，返回<code>BetterLogger</code>。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<a id=\"class-provider-dependencies\"></a>\n<h3 translation-origin=\"off\" id=\"class-provider-with-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#class-provider-with-dependencies\"><i class=\"material-icons\">link</i></a>Class provider with dependencies</h3>\n<h3 translation-result=\"\" id=\"class-provider-with-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#class-provider-with-dependencies\"><i class=\"material-icons\">link</i></a>带依赖的类提供商</h3>\n<p translation-origin=\"off\">Maybe an <code>EvenBetterLogger</code> could display the user name in the log message.\nThis logger gets the user from the injected <code>UserService</code>,\nwhich is also injected at the application level.</p>\n<p translation-result=\"\">假设<code>EvenBetterLogger</code>可以在日志消息中显示用户名。\n这个日志服务从注入的<code>UserService</code>中取得用户，\n<code>UserService</code>通常也会在应用级注入。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  log(message: string) {\n    let name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">Configure it like <code>BetterLogger</code>.</p>\n<p translation-result=\"\">就像之前在<code>BetterLogger</code>中那样配置它。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\" linenums=\"false\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<a id=\"aliased-class-providers\"></a>\n<h3 translation-origin=\"off\" id=\"aliased-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#aliased-class-providers\"><i class=\"material-icons\">link</i></a>Aliased class providers</h3>\n<h3 translation-result=\"\" id=\"aliased-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#aliased-class-providers\"><i class=\"material-icons\">link</i></a>别名类提供商</h3>\n<p translation-origin=\"off\">Suppose an old component depends upon an <code>OldLogger</code> class.\n<code>OldLogger</code> has the same interface as the <code>NewLogger</code>, but for some reason\nyou can't update the old component to use it.</p>\n<p translation-result=\"\">假设某个旧组件依赖一个<code>OldLogger</code>类。\n<code>OldLogger</code>和<code>NewLogger</code>具有相同的接口，但是由于某些原因，\n我们不能升级这个旧组件并使用它。</p>\n<p translation-origin=\"off\">When the <em>old</em> component logs a message with <code>OldLogger</code>,\nyou'd like the singleton instance of <code>NewLogger</code> to handle it instead.</p>\n<p translation-result=\"\">当<em>旧</em>组件想使用<code>OldLogger</code>记录消息时，我们希望改用<code>NewLogger</code>的单例对象来记录。</p>\n<p translation-origin=\"off\">The dependency injector should inject that singleton instance\nwhen a component asks for either the new or the old logger.\nThe <code>OldLogger</code> should be an alias for <code>NewLogger</code>.</p>\n<p translation-result=\"\">不管组件请求的是新的还是旧的日志服务，依赖注入器注入的都应该是同一个单例对象。\n也就是说，<code>OldLogger</code>应该是<code>NewLogger</code>的别名。</p>\n<p translation-origin=\"off\">You certainly do not want two different <code>NewLogger</code> instances in your app.\nUnfortunately, that's what you get if you try to alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>.</p>\n<p translation-result=\"\">我们当然不会希望应用中有两个不同的<code>NewLogger</code>实例。\n不幸的是，如果尝试通过<code>useClass</code>来把<code>OldLogger</code>作为<code>NewLogger</code>的别名，就会导致这样的后果。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6a\" linenums=\"false\">\n[ NewLogger,\n  // Not aliased! Creates two instances of `NewLogger`\n  { provide: OldLogger, useClass: NewLogger}]\n\n</code-example>\n<p translation-origin=\"off\">The solution: alias with the <code>useExisting</code> option.</p>\n<p translation-result=\"\">解决方案：使用<code>useExisting</code>选项指定别名。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\" linenums=\"false\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<a id=\"value-provider\"></a>\n<h3 translation-origin=\"off\" id=\"value-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#value-providers\"><i class=\"material-icons\">link</i></a>Value providers</h3>\n<h3 translation-result=\"\" id=\"value-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#value-providers\"><i class=\"material-icons\">link</i></a>值提供商</h3>\n<p translation-origin=\"off\">Sometimes it's easier to provide a ready-made object rather than ask the injector to create it from a class.</p>\n<p translation-result=\"\">有时，提供一个预先做好的对象会比请求注入器从类中创建它更容易。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\" linenums=\"false\">\n// An object in the shape of the logger service\nexport function SilentLoggerFn() {}\n\nconst silentLogger = {\n  logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'],\n  log: SilentLoggerFn\n};\n\n</code-example>\n<p translation-origin=\"off\">Then you register a provider with the <code>useValue</code> option,\nwhich makes this object play the logger role.</p>\n<p translation-result=\"\">于是可以通过<code>useValue</code>选项来注册提供商，它会让这个对象直接扮演 logger 的角色。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\" linenums=\"false\">\n[{ provide: Logger, useValue: silentLogger }]\n\n</code-example>\n<p translation-origin=\"off\">See more <code>useValue</code> examples in the\n<a href=\"guide/dependency-injection#non-class-dependencies\">Non-class dependencies</a> and\n<a href=\"guide/dependency-injection#injection-token\">InjectionToken</a> sections.</p>\n<p translation-result=\"\">查看更多<code>useValue</code>的例子，见<a href=\"guide/dependency-injection#non-class-dependencies\">非类依赖</a>和 <a href=\"guide/dependency-injection#injection-token\">InjectionToken</a>部分。</p>\n<a id=\"factory-provider\"></a>\n<h3 translation-origin=\"off\" id=\"factory-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#factory-providers\"><i class=\"material-icons\">link</i></a>Factory providers</h3>\n<h3 translation-result=\"\" id=\"factory-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#factory-providers\"><i class=\"material-icons\">link</i></a>工厂提供商</h3>\n<p translation-origin=\"off\">Sometimes you need to create the dependent value dynamically,\nbased on information you won't have until the last possible moment.\nMaybe the information changes repeatedly in the course of the browser session.</p>\n<p translation-result=\"\">有时，我们需要动态创建这个依赖值，因为它所需要的信息直到最后一刻才能确定。\n也许这个信息会在浏览器的会话中不停地变化。</p>\n<p translation-origin=\"off\">Suppose also that the injectable service has no independent access to the source of this information.</p>\n<p translation-result=\"\">还假设这个可注入的服务没法通过独立的源访问此信息。</p>\n<p translation-origin=\"off\">This situation calls for a <strong>factory provider</strong>.</p>\n<p translation-result=\"\">这种情况下，请调用<strong>工厂提供商</strong>。</p>\n<p translation-origin=\"off\">To illustrate the point, add a new business requirement:\nthe <code>HeroService</code> must hide <em>secret</em> heroes from normal users.\nOnly authorized users should see secret heroes.</p>\n<p translation-result=\"\">下面通过添加新的业务需求来说明这一点：\n<code>HeroService</code> 必须对普通用户隐藏掉<em>秘密</em>英雄。\n只有授权用户才能看到秘密英雄。</p>\n<p translation-origin=\"off\">Like the <code>EvenBetterLogger</code>, the <code>HeroService</code> needs a fact about the user.\nIt needs to know if the user is authorized to see secret heroes.\nThat authorization can change during the course of a single application session,\nas when you log in a different user.</p>\n<p translation-result=\"\">就像<code>EvenBetterLogger</code>那样，<code>HeroService</code>需要了解此用户的身份。\n它需要知道，这个用户是否有权看到隐藏英雄。\n这个授权可能在单一的应用会话中被改变，例如，改用另一个用户的身份登录时。</p>\n<p translation-origin=\"off\">Unlike <code>EvenBetterLogger</code>, you can't inject the <code>UserService</code> into the <code>HeroService</code>.\nThe <code>HeroService</code> won't have direct access to the user information to decide\nwho is authorized and who is not.</p>\n<p translation-result=\"\">与<code>EvenBetterLogger</code>不同，不能把<code>UserService</code>注入到<code>HeroService</code>中。\n<code>HeroService</code>无权访问用户信息，来决定谁有授权谁没有授权。</p>\n<p translation-origin=\"off\">Instead, the <code>HeroService</code> constructor takes a boolean flag to control display of secret heroes.</p>\n<p translation-result=\"\">让<code>HeroService</code>的构造函数带上一个布尔型的标志，来控制是否显示隐藏的英雄。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" title=\"src/app/heroes/hero.service.ts (excerpt)\" linenums=\"false\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p translation-origin=\"off\">You can inject the <code>Logger</code>, but you can't inject the  boolean <code>isAuthorized</code>.\nYou'll have to take over the creation of new instances of this <code>HeroService</code> with a factory provider.</p>\n<p translation-result=\"\">我们可以注入<code>Logger</code>，但是不能注入逻辑型的<code>isAuthorized</code>。\n我们不得不通过通过工厂提供商创建这个<code>HeroService</code>的新实例。</p>\n<p translation-origin=\"off\">A factory provider needs a factory function:</p>\n<p translation-result=\"\">工厂提供商需要一个工厂方法：</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nlet heroServiceFactory = (logger: Logger, userService: UserService) => {\n  return new HeroService(logger, userService.user.isAuthorized);\n};\n\n</code-example>\n<p translation-origin=\"off\">Although the <code>HeroService</code> has no access to the <code>UserService</code>, the factory function does.</p>\n<p translation-result=\"\">虽然<code>HeroService</code>不能访问<code>UserService</code>，但是工厂方法可以。</p>\n<p translation-origin=\"off\">You inject both the <code>Logger</code> and the <code>UserService</code> into the factory provider\nand let the injector pass them along to the factory function:</p>\n<p translation-result=\"\">同时把<code>Logger</code>和<code>UserService</code>注入到工厂提供商中，并且让注入器把它们传给工厂方法：</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nexport let heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">The <code>useFactory</code> field tells Angular that the provider is a factory function\nwhose implementation is the <code>heroServiceFactory</code>.</p>\n<p translation-result=\"\"><code>useFactory</code>字段告诉 Angular：这个提供商是一个工厂方法，它的实现是<code>heroServiceFactory</code>。</p>\n<p translation-origin=\"off\">The <code>deps</code> property is an array of <a href=\"guide/dependency-injection#token\">provider tokens</a>.\nThe <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching factory function parameters.</p>\n<p translation-result=\"\"><code>deps</code>属性是<a href=\"guide/dependency-injection#token\">提供商令牌</a>数组。\n<code>Logger</code>和<code>UserService</code>类作为它们自身类提供商的令牌。\n注入器解析这些令牌，把相应的服务注入到工厂函数中相应的参数中去。</p>\n</div>\n<p translation-origin=\"off\">Notice that you captured the factory provider in an exported variable, <code>heroServiceProvider</code>.\nThis extra step makes the factory provider reusable.\nYou can register the <code>HeroService</code> with this variable wherever you need it.</p>\n<p translation-result=\"\">注意，我们在一个导出的变量中捕获了这个工厂提供商：<code>heroServiceProvider</code>。\n这个额外的步骤让工厂提供商可被复用。\n无论哪里需要，都可以使用这个变量注册<code>HeroService</code>。</p>\n<p translation-origin=\"off\">In this sample, you need it only in the <code>HeroesComponent</code>,\nwhere it replaces the previous <code>HeroService</code> registration in the metadata <code>providers</code> array.\nHere you see the new and the old implementation side-by-side:</p>\n<p translation-result=\"\">在这个例子中，只在<code>HeroesComponent</code>中需要它，\n这里，它代替了元数据<code>providers</code>数组中原来的<code>HeroService</code>注册。\n对比一下新的和旧的实现：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v3)\" path=\"dependency-injection/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }          from '@angular/core';\nimport { heroServiceProvider } from './hero.service.provider';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ heroServiceProvider ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v2)\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n</code-tabs>\n<a id=\"token\"></a>\n<h2 translation-origin=\"off\" id=\"dependency-injection-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a>Dependency injection tokens</h2>\n<h2 translation-result=\"\" id=\"dependency-injection-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a>依赖注入令牌</h2>\n<p translation-origin=\"off\">When you register a provider with an injector, you associate that provider with a dependency injection token.\nThe injector maintains an internal <em>token-provider</em> map that it references when\nasked for a dependency. The token is the key to the map.</p>\n<p translation-result=\"\">当向注入器注册提供商时，实际上是把这个提供商和一个 DI 令牌关联起来了。\n注入器维护一个内部的<em>令牌-提供商</em>映射表，这个映射表会在请求依赖时被引用到。\n令牌就是这个映射表中的键值。</p>\n<p translation-origin=\"off\">In all previous examples, the dependency value has been a class <em>instance</em>, and\nthe class <em>type</em> served as its own lookup key.\nHere you get a <code>HeroService</code> directly from the injector by supplying the <code>HeroService</code> type as the token:</p>\n<p translation-result=\"\">在前面的所有例子中，依赖值都是一个类<em>实例</em>，并且类的<em>类型</em>作为它自己的查找键值。\n在下面的代码中，<code>HeroService</code>类型作为令牌，直接从注入器中获取<code>HeroService</code> 实例：</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" title=\"src/app/injector.component.ts\" linenums=\"false\">\nheroService: HeroService;\n\n</code-example>\n<p translation-origin=\"off\">You have similar good fortune when you write a constructor that requires an injected class-based dependency.\nWhen you define a constructor parameter with the <code>HeroService</code> class type,\nAngular knows to inject the\nservice associated with that <code>HeroService</code> class token:</p>\n<p translation-result=\"\">编写需要基于类的依赖注入的构造函数对我们来说是很幸运的。\n只要定义一个<code>HeroService</code>类型的构造函数参数，\nAngular 就会知道把跟<code>HeroService</code>类令牌关联的服务注入进来：</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" title=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p translation-origin=\"off\">This is especially convenient when you consider that most dependency values are provided by classes.</p>\n<p translation-result=\"\">这是一个特殊的规约，因为大多数依赖值都是以类的形式提供的。</p>\n<a id=\"non-class-dependencies\"></a>\n<h3 translation-origin=\"off\" id=\"non-class-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#non-class-dependencies\"><i class=\"material-icons\">link</i></a>Non-class dependencies</h3>\n<h3 translation-result=\"\" id=\"non-class-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#non-class-dependencies\"><i class=\"material-icons\">link</i></a>非类依赖</h3>\n<p translation-origin=\"off\">What if the dependency value isn't a class? Sometimes the thing you want to inject is a\nstring, function, or object.</p>\n<p translation-result=\"\">如果依赖值不是一个类呢？有时候想要注入的东西是一个字符串，函数或者对象。</p>\n<p translation-origin=\"off\">Applications often define configuration objects with lots of small facts\n(like the title of the application or the address of a web API endpoint)\nbut these configuration objects aren't always instances of a class.\nThey can be object literals such as this one:</p>\n<p translation-result=\"\">应用程序经常为很多很小的因素定义配置对象（例如应用程序的标题或网络API终点的地址）。\n但是这些配置对象不总是类的实例，它们可能是对象，如下面这个：</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" title=\"src/app/app.config.ts (excerpt)\" linenums=\"false\">\nexport const HERO_DI_CONFIG: AppConfig = {\n  apiEndpoint: 'api.heroes.com',\n  title: 'Dependency Injection'\n};\n\n\n</code-example>\n<p translation-origin=\"off\">What if you'd like to make this configuration object available for injection?\nYou know you can register an object with a <a href=\"guide/dependency-injection#value-provider\">value provider</a>.</p>\n<p translation-result=\"\">我们想让这个配置对象在注入时可用，而且知道可以使用<a href=\"guide/dependency-injection#value-provider\">值提供商</a>来注册一个对象。</p>\n<p translation-origin=\"off\">But what should you use as the token?\nYou don't have a class to serve as a token.\nThere is no <code>AppConfig</code> class.</p>\n<p translation-result=\"\">但是，这种情况下用什么作令牌呢？\n我们没办法找一个类来当作令牌，因为没有<code>Config</code>类。</p>\n<div class=\"l-sub-section\">\n<h3 translation-origin=\"off\" id=\"typescript-interfaces-arent-valid-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#typescript-interfaces-arent-valid-tokens\"><i class=\"material-icons\">link</i></a>TypeScript interfaces aren't valid tokens</h3>\n<h3 translation-result=\"\" id=\"typescript-interfaces-arent-valid-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#typescript-interfaces-arent-valid-tokens\"><i class=\"material-icons\">link</i></a>TypeScript 接口不是一个有效的令牌</h3>\n<p translation-origin=\"off\">The <code>HERO_DI_CONFIG</code> constant conforms to the <code>AppConfig</code> interface.\nUnfortunately, you cannot use a TypeScript interface as a token:</p>\n<p translation-result=\"\"><code>HERO_DI_CONFIG</code>常量有一个接口：<code>AppConfig</code>。不幸的是，不能把 TypeScript 接口用作令牌：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\" linenums=\"false\">\n// FAIL! Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\" linenums=\"false\">\n// FAIL! Can't <a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<p translation-origin=\"off\">That seems strange if you're used to dependency injection in strongly typed languages, where\nan interface is the preferred dependency lookup key.</p>\n<p translation-result=\"\">对于习惯于在强类型的语言中使用依赖注入的开发人员，这会看起来很奇怪，\n因为在强类型语言中，接口是首选的用于查找依赖的主键。</p>\n<p translation-origin=\"off\">It's not Angular's doing. An interface is a TypeScript design-time artifact. JavaScript doesn't have interfaces.\nThe TypeScript interface disappears from the generated JavaScript.\nThere is no interface type information left for Angular to find at runtime.</p>\n<p translation-result=\"\">这不是 Angular 的错。接口只是 TypeScript 设计时 (design-time) 的概念。JavaScript 没有接口。\nTypeScript 接口不会出现在生成的 JavaScript 代码中。\n在运行期，没有接口类型信息可供 Angular 查找。</p>\n</div>\n<a id=\"injection-token\"></a>\n<h3 translation-origin=\"off\" id=\"injectiontoken\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injectiontoken\"><i class=\"material-icons\">link</i></a><em>InjectionToken</em></h3>\n<h3 translation-result=\"\" id=\"eminjectiontokenem-1\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#eminjectiontokenem-1\"><i class=\"material-icons\">link</i></a><em>InjectionToken</em> 值</h3>\n<p translation-origin=\"off\">One solution to choosing a provider token for non-class dependencies is\nto define and use an <a href=\"api/core/InjectionToken\"><em>InjectionToken</em></a>.\nThe definition of such a token looks like this:</p>\n<p translation-result=\"\">解决方案是为非类依赖定义和使用<a href=\"../api/core/InjectionToken\"><b>InjectionToken</b></a>作为提供商令牌。\n定义方式是这样的：</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" title=\"src/app/app.config.ts\" linenums=\"false\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;AppConfig>('app.config');\n\n</code-example>\n<p translation-origin=\"off\">The type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.</p>\n<p translation-result=\"\">类型参数，虽然是可选的，但可以向开发者和开发工具传达类型信息。\n而且这个令牌的描述信息也可以为开发者提供帮助。</p>\n<p translation-origin=\"off\">Register the dependency provider using the <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object:</p>\n<p translation-result=\"\">使用这个<code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>对象注册依赖的提供商：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9\" linenums=\"false\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p translation-origin=\"off\">Now you can inject the configuration object into any constructor that needs it, with\nthe help of an <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> decorator:</p>\n<p translation-result=\"\">现在，在<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>装饰器的帮助下，这个配置对象可以注入到任何需要它的构造函数中：</p>\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" title=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">Although the <code>AppConfig</code> interface plays no role in dependency injection,\nit supports typing of the configuration object within the class.</p>\n<p translation-result=\"\">虽然<code>AppConfig</code>接口在依赖注入过程中没有任何作用，但它为该类中的配置对象提供了强类型信息。</p>\n</div>\n<p translation-origin=\"off\">Alternatively, you can provide and inject the configuration object in an ngModule like <code>AppModule</code>.</p>\n<p translation-result=\"\">或者在 ngModule 中提供并注入这个配置对象，如<code>AppModule</code>。</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<a id=\"optional\"></a>\n<h2 translation-origin=\"off\" id=\"optional-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#optional-dependencies\"><i class=\"material-icons\">link</i></a>Optional dependencies</h2>\n<h2 translation-result=\"\" id=\"optional-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#optional-dependencies\"><i class=\"material-icons\">link</i></a>可选依赖</h2>\n<p translation-origin=\"off\">The <code>HeroService</code> <em>requires</em> a <code>Logger</code>, but what if it could get by without\na <code>logger</code>?\nYou can tell Angular that the dependency is optional by annotating the\nconstructor argument with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>:</p>\n<p translation-result=\"\"><code>HeroService</code><em>需要</em>一个<code>Logger</code>，但是如果想不提供 Logger 也能得到它，该怎么办呢？\n可以把构造函数的参数标记为<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，告诉 Angular 该依赖是可选的：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> } from '@angular/core';\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() private logger: Logger) {\n  if (this.logger) {\n    this.logger.log(some_message);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">When using <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, your code must be prepared for a null value. If you\ndon't register a <code>logger</code> somewhere up the line, the injector will set the\nvalue of <code>logger</code> to null.</p>\n<p translation-result=\"\">当使用<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>时，代码必须准备好如何处理空值。\n如果其它的代码没有注册一个 <code>logger</code>，注入器会设置该<code>logger</code>的值为空 null。</p>\n<h2 translation-origin=\"off\" id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#summary\"><i class=\"material-icons\">link</i></a>Summary</h2>\n<h2 translation-result=\"\" id=\"summary-2\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#summary-2\"><i class=\"material-icons\">link</i></a>小结</h2>\n<p translation-origin=\"off\">You learned the basics of Angular dependency injection in this page.\nYou can register various kinds of providers,\nand you know how to ask for an injected object (such as a service) by\nadding a parameter to a constructor.</p>\n<p translation-result=\"\">本章，我们学习了 Angular 依赖注入的基础知识。\n我们可以注册很多种类的提供商，知道如何通过添加构造函数的参数来请求一个注入对象（例如一个服务）。</p>\n<p translation-origin=\"off\">Angular dependency injection is more capable than this guide has described.\nYou can learn more about its advanced features, beginning with its support for\nnested injectors, in\n<a href=\"guide/hierarchical-dependency-injection\">Hierarchical Dependency Injection</a>.</p>\n<p translation-result=\"\">Angular 依赖注入比前面描述的更能干。\n学习更多高级特性，如对嵌套注入器的支持，见<a href=\"guide/hierarchical-dependency-injection\">多级依赖注入</a>一章。</p>\n<a id=\"explicit-injector\"></a>\n<h2 translation-origin=\"off\" id=\"appendix-working-with-injectors-directly\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-working-with-injectors-directly\"><i class=\"material-icons\">link</i></a>Appendix: Working with injectors directly</h2>\n<h2 translation-result=\"\" id=\"appendix-working-with-injectors-directly\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-working-with-injectors-directly\"><i class=\"material-icons\">link</i></a>附录：直接使用注入器</h2>\n<p translation-origin=\"off\">Developers rarely work directly with an injector, but\nhere's an <code>InjectorComponent</code> that does.</p>\n<p translation-result=\"\">这里的<code>InjectorComponent</code>直接使用了注入器，\n但我们很少直接使用它。</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"injector\" title=\"src/app/injector.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-injectors',\n  template: `\n  &#x3C;h2>Other Injections&#x3C;/h2>\n  &#x3C;div id=\"car\">{{car.drive()}}&#x3C;/div>\n  &#x3C;div id=\"hero\">{{hero.name}}&#x3C;/div>\n  &#x3C;div id=\"rodent\">{{rodent}}&#x3C;/div>\n  `,\n  providers: [Car, Engine, Tires, heroServiceProvider, Logger]\n})\nexport class InjectorComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  car: Car;\n\n  heroService: HeroService;\n  hero: Hero;\n\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) { }\n\n  ngOnInit() {\n    this.car = this.injector.get(Car);\n    this.heroService = this.injector.get(HeroService);\n    this.hero = this.heroService.getHeroes()[0];\n  }\n\n  get rodent() {\n    let rousDontExist = `R.O.U.S.'s? I don't think they exist!`;\n    return this.injector.get(ROUS, rousDontExist);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">An <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> is itself an injectable service.</p>\n<p translation-result=\"\"><code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code>本身是可注入的服务。</p>\n<p translation-origin=\"off\">In this example, Angular injects the component's own <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> into the component's constructor.\nThe component then asks the injected injector for the services it wants in <code>ngOnInit()</code>.</p>\n<p translation-result=\"\">在这个例子中，Angular 把组件自身的<code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code>注入到了组件的构造函数中。\n然后，组件在<code>ngOnInit()</code>中向注入的注入器请求它所需的服务。</p>\n<p translation-origin=\"off\">Note that the services themselves are not injected into the component.\nThey are retrieved by calling <code>injector.get()</code>.</p>\n<p translation-result=\"\">注意，这些服务本身没有注入到组件，它们是通过调用<code>injector.get()</code>获得的。</p>\n<p translation-origin=\"off\">The <code>get()</code> method throws an error if it can't resolve the requested service.\nYou can call <code>get()</code> with a second parameter, which is the value to return if the service\nis not found. Angular can't find the service if it's not registered with this or any ancestor injector.</p>\n<p translation-result=\"\"><code>get()</code>方法如果不能解析所请求的服务，会抛出异常。\n调用<code>get()</code>时，还可以使用第二个参数，一旦获取的服务没有在当前或任何祖先注入器中注册过，\n就把它作为返回值。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">The technique is an example of the\n<a href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\">service locator pattern</a>.</p>\n<p translation-result=\"\">刚描述的这项技术是<a href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\">服务定位器模式</a>的一个范例。</p>\n<p translation-origin=\"off\"><strong>Avoid</strong> this technique unless you genuinely need it.\nIt encourages a careless grab-bag approach such as you see here.\nIt's difficult to explain, understand, and test.\nYou can't know by inspecting the constructor what this class requires or what it will do.\nIt could acquire services from any ancestor component, not just its own.\nYou're forced to spelunk the implementation to discover what it does.</p>\n<p translation-result=\"\">要<strong>避免使用</strong>此技术，除非确实需要它。\n它会鼓励鲁莽的方式，就像在这里看到的。\n它难以解释、理解和测试。\n仅通过阅读构造函数，没法知道这个类需要什么或者它将做什么。\n它可以从任何祖先组件中获得服务，而不仅仅是它自己。\n会迫使我们深入它的实现，才可能明白它都做了啥。</p>\n<p translation-origin=\"off\">Framework developers may take this approach when they\nmust acquire services generically and dynamically.</p>\n<p translation-result=\"\">框架开发人员必须采用通用的或者动态的方式获取服务时，可能采用这个方法。</p>\n</div>\n<a id=\"one-class-per-file\"></a>\n<h2 translation-origin=\"off\" id=\"appendix-one-class-per-file\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-one-class-per-file\"><i class=\"material-icons\">link</i></a>Appendix: one class per file</h2>\n<h2 translation-result=\"\" id=\"appendix-one-class-per-file\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-one-class-per-file\"><i class=\"material-icons\">link</i></a>附录：为什么建议每个文件只放一个类</h2>\n<p translation-origin=\"off\">Having multiple classes in the same file is confusing and best avoided.\nDevelopers expect one class per file. Keep them happy.</p>\n<p translation-result=\"\">在同一个文件中有多个类容易造成混淆，最好避免。\n开发人员期望每个文件只放一个类。这会让它们开心点。</p>\n<p translation-origin=\"off\">If you combine the <code>HeroService</code> class with\nthe <code>HeroesComponent</code> in the same file,\n<strong>define the component last</strong>.\nIf you define the component before the service,\nyou'll get a runtime null reference error.</p>\n<p translation-result=\"\">如果我们蔑视这个建议，并且 —— 比如说 —— 把<code>HeroService</code>和<code>HeroesComponent</code>组合在同一个文件里，\n<strong>就得把组件定义放在最后面！</strong>\n如果把组件定义在了服务的前面，\n在运行时抛出空指针错误。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">You actually can define the component first with the help of the <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> method as explained\nin this <a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">blog post</a>.</p>\n<p translation-result=\"\">在<code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code>方法的帮助下，实际上也可以先定义组件，\n具体说明见这篇<a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">博客</a>。</p>\n<p translation-origin=\"off\">But it's best to avoid the problem altogether by defining components and services in separate files.</p>\n<p translation-result=\"\">但是为什么要先给自己找麻烦呢？\n还是通过在独立的文件中定义组件和服务，完全避免此问题吧。</p>\n</div>\n\n</div>\n<!-- links to this doc:\n - api/core/ClassProvider\n - api/core/ExistingProvider\n - api/core/FactoryProvider\n - api/core/Host\n - api/core/HostDecorator\n - api/core/Inject\n - api/core/InjectDecorator\n - api/core/Injectable\n - api/core/InjectableDecorator\n - api/core/Injector\n - api/core/Optional\n - api/core/OptionalDecorator\n - api/core/Provider\n - api/core/Self\n - api/core/SelfDecorator\n - api/core/SkipSelf\n - api/core/SkipSelfDecorator\n - api/core/StaticProvider\n - api/core/TypeProvider\n - api/core/ValueProvider\n - guide/attribute-directives\n - guide/dependency-injection-in-action\n - guide/dependency-injection-pattern\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/http\n - guide/router\n - guide/sharing-ngmodules\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - ../api/core/InjectionToken\n - api/common/NgForOf\n - api/core/Component\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Injector\n - api/core/NgModule\n - api/core/OnInit\n - api/core/Optional\n - api/core/forwardRef\n - api/core/testing/inject\n - guide/bootstrapping\n - guide/dependency-injection#aliased-class-providers\n - guide/dependency-injection#alternative-class-providers\n - guide/dependency-injection#angular-dependency-injection\n - guide/dependency-injection#appendix-one-class-per-file\n - guide/dependency-injection#appendix-working-with-injectors-directly\n - guide/dependency-injection#class-provider-with-dependencies\n - guide/dependency-injection#component-child-injectors\n - guide/dependency-injection#component-providers\n - guide/dependency-injection#create-an-injectable-emheroserviceem\n - guide/dependency-injection#create-an-injectable-heroservice\n - guide/dependency-injection#dependency-injection-tokens\n - guide/dependency-injection#di-by-example\n - guide/dependency-injection#emcomponentem-providers\n - guide/dependency-injection#eminjectiontokenem-1\n - guide/dependency-injection#emngmoduleem-or-emcomponentem\n - guide/dependency-injection#emngmoduleem-providers\n - guide/dependency-injection#factory-providers\n - guide/dependency-injection#inject-a-service\n - guide/dependency-injection#injectable\n - guide/dependency-injection#injection-token\n - guide/dependency-injection#injectiontoken\n - guide/dependency-injection#ngmodule-or-component\n - guide/dependency-injection#ngmodule-providers\n - guide/dependency-injection#non-class-dependencies\n - guide/dependency-injection#one-class-per-file\n - guide/dependency-injection#optional-dependencies\n - guide/dependency-injection#providers\n - guide/dependency-injection#register-a-service-provider\n - guide/dependency-injection#singleton-services\n - guide/dependency-injection#summary\n - guide/dependency-injection#summary-2\n - guide/dependency-injection#testing-the-component\n - guide/dependency-injection#the-class-as-its-own-provider\n - guide/dependency-injection#the-dependent-emloggerem-service\n - guide/dependency-injection#the-dependent-logger-service\n - guide/dependency-injection#the-emprovideem-object-literal-1\n - guide/dependency-injection#the-provide-object-literal\n - guide/dependency-injection#token\n - guide/dependency-injection#typescript-interfaces-arent-valid-tokens\n - guide/dependency-injection#value-provider\n - guide/dependency-injection#value-providers\n - guide/dependency-injection#when-the-service-needs-a-service\n - guide/dependency-injection-pattern\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/testing\n - tutorial/\n - http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\n - https://cli.angular.io/\n - https://en.wikipedia.org/wiki/Service_locator_pattern\n-->"
}